# 訂單建立多天功能 - 規劃文檔

## 功能概述

### 目標
為 LC-management 長照服務管理系統新增多天訂單建立功能，讓用戶能夠一次性為同一客戶建立多個不同日期的相同服務訂單，提高工作效率並減少重複操作。

### 使用場景
1. **定期復健接送**：客戶需要在指定的多個日期（如每月的 5、15、25 日）進行復健治療
2. **醫療回診安排**：客戶在不規律的日期需要相同的醫療接送服務
3. **特殊活動安排**：為特定活動日期批量建立相同的服務訂單

### 功能價值
- **提升效率**：減少重複的資料輸入工作
- **降低錯誤**：統一的訂單資訊減少人為輸入錯誤
- **改善體驗**：簡化複雜的批量訂單建立流程
- **節省時間**：大幅減少多筆相似訂單的建立時間

## 技術需求分析

### 前端需求
1. **日期選擇模式切換**
   - 單日模式（現有）
   - 多日模式（新增）
   
2. **多日期選擇器**
   - 支援選擇多個不連續日期
   - 視覺化顯示已選擇的日期
   - 支援日期的新增、刪除和編輯

3. **訂單預覽功能**
   - 顯示將要建立的所有訂單預覽
   - 顯示總訂單數量和基本資訊
   - 提供確認建立或取消的選項

4. **批量建立進度**
   - 顯示建立進度條
   - 即時更新建立狀態
   - 錯誤處理和報告

### 後端需求
1. **批量處理邏輯**
   - 批量訂單資料驗證
   - 重複訂單檢查優化
   - 資料庫事務處理

2. **記憶體管理**
   - 分批處理機制
   - 記憶體使用監控
   - 效能優化

3. **錯誤處理**
   - 部分失敗的處理機制
   - 詳細的錯誤報告
   - 失敗訂單的重試機制

### 資料庫影響
1. **新增欄位（可選）**
   - `batch_id`：標記批量建立的訂單
   - `batch_sequence`：批量內的序號
   
2. **索引優化**
   - 為批量查詢新增複合索引
   - 優化日期範圍查詢效能

## 詳細實施方案

### 1. 前端介面設計

#### 日期選擇模式切換
```html
<div class="date-mode-selector mb-3">
    <div class="btn-group" role="group">
        <input type="radio" class="btn-check" name="date_mode" id="single_day" value="single" checked>
        <label class="btn btn-outline-primary" for="single_day">單日訂單</label>
        
        <input type="radio" class="btn-check" name="date_mode" id="multiple_days" value="multiple">
        <label class="btn btn-outline-primary" for="multiple_days">多日訂單</label>
    </div>
</div>
```

#### 多日期選擇器
```html
<div id="multiple-dates-section" style="display: none;">
    <div class="row">
        <div class="col-md-6">
            <label class="form-label">選擇日期</label>
            <input type="text" id="multiple-date-picker" class="form-control" placeholder="點擊選擇多個日期">
        </div>
        <div class="col-md-6">
            <label class="form-label">已選擇的日期</label>
            <div id="selected-dates-list" class="selected-dates-container">
                <div class="text-muted">尚未選擇任何日期</div>
            </div>
        </div>
    </div>
</div>
```

#### 訂單預覽區域
```html
<div id="batch-preview-section" style="display: none;">
    <div class="card mt-3">
        <div class="card-header">
            <h5 class="mb-0">批量訂單預覽</h5>
        </div>
        <div class="card-body">
            <div class="batch-summary mb-3">
                <span class="badge bg-primary fs-6">將建立 <span id="total-orders">0</span> 筆訂單</span>
            </div>
            <div id="batch-orders-preview" class="table-responsive">
                <!-- 動態生成訂單預覽表格 -->
            </div>
        </div>
    </div>
</div>
```

### 2. 後端服務設計

#### BatchOrderService 類別
```php
<?php

namespace App\Services;

use App\Models\Order;
use App\Models\Customer;
use App\Services\CarpoolGroupService;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class BatchOrderService
{
    protected $carpoolGroupService;
    
    public function __construct(CarpoolGroupService $carpoolGroupService)
    {
        $this->carpoolGroupService = $carpoolGroupService;
    }
    
    /**
     * 建立多天訂單
     */
    public function createMultipleDaysOrders($orderData, $dates)
    {
        // 驗證日期陣列
        $this->validateDates($dates);
        
        // 檢查重複訂單
        $conflicts = $this->checkDuplicateOrders($orderData['customer_id'], $dates, $orderData['ride_time']);
        
        if (!empty($conflicts)) {
            throw new \Exception('存在重複訂單：' . implode(', ', $conflicts));
        }
        
        // 生成批次 ID
        $batchId = 'batch_' . time() . '_' . rand(1000, 9999);
        
        return DB::transaction(function () use ($orderData, $dates, $batchId) {
            $createdOrders = [];
            $errors = [];
            
            foreach ($dates as $index => $date) {
                try {
                    $orderDataWithDate = array_merge($orderData, [
                        'ride_date' => $date,
                        'batch_id' => $batchId,
                        'batch_sequence' => $index + 1,
                    ]);
                    
                    if (!empty($orderData['carpool_customer_id'])) {
                        // 共乘訂單
                        $result = $this->carpoolGroupService->createCarpoolGroup(
                            $orderData['customer_id'],
                            $orderData['carpool_customer_id'],
                            $orderDataWithDate
                        );
                        $createdOrders = array_merge($createdOrders, $result['orders']);
                    } else {
                        // 單人訂單
                        $order = $this->createSingleOrder($orderDataWithDate);
                        $createdOrders[] = $order;
                        
                        // 處理回程訂單
                        if (!empty($orderData['back_time'])) {
                            $returnOrder = $this->createReturnOrder($orderDataWithDate, $order);
                            $createdOrders[] = $returnOrder;
                        }
                    }
                    
                } catch (\Exception $e) {
                    $errors[] = [
                        'date' => $date,
                        'error' => $e->getMessage()
                    ];
                    Log::error('批量建立訂單失敗', [
                        'date' => $date,
                        'error' => $e->getMessage(),
                        'batch_id' => $batchId
                    ]);
                }
            }
            
            return [
                'batch_id' => $batchId,
                'successful_orders' => $createdOrders,
                'failed_dates' => $errors,
                'total_created' => count($createdOrders),
                'total_failed' => count($errors)
            ];
        });
    }
    
    /**
     * 驗證日期陣列
     */
    private function validateDates($dates)
    {
        if (empty($dates)) {
            throw new \Exception('請選擇至少一個日期');
        }
        
        if (count($dates) > 50) {
            throw new \Exception('單次最多只能建立 50 筆訂單');
        }
        
        foreach ($dates as $date) {
            $parsedDate = Carbon::parse($date);
            
            // 檢查日期不能是過去
            if ($parsedDate->isPast()) {
                throw new \Exception("日期 {$date} 不能是過去的日期");
            }
            
            // 檢查日期不能超過 6 個月
            if ($parsedDate->diffInMonths(Carbon::now()) > 6) {
                throw new \Exception("日期 {$date} 超過 6 個月限制");
            }
        }
    }
    
    /**
     * 檢查重複訂單
     */
    private function checkDuplicateOrders($customerId, $dates, $time)
    {
        $conflicts = [];
        
        $existingOrders = Order::where('customer_id', $customerId)
            ->where('ride_time', $time)
            ->whereIn('ride_date', $dates)
            ->pluck('ride_date')
            ->toArray();
            
        foreach ($existingOrders as $conflictDate) {
            $conflicts[] = Carbon::parse($conflictDate)->format('Y-m-d');
        }
        
        return $conflicts;
    }
    
    /**
     * 建立單人訂單（簡化版）
     */
    private function createSingleOrder($orderData)
    {
        // 使用現有的 OrderController 中的邏輯
        // 這裡簡化處理，實際應該抽取共用邏輯
        return Order::create($this->prepareOrderData($orderData));
    }
    
    /**
     * 建立回程訂單（簡化版）
     */
    private function createReturnOrder($orderData, $outboundOrder)
    {
        // 使用現有的回程訂單建立邏輯
        $returnData = array_merge($orderData, [
            'ride_time' => $orderData['back_time'],
            'pickup_address' => $orderData['dropoff_address'],
            'dropoff_address' => $orderData['pickup_address'],
        ]);
        
        return Order::create($this->prepareOrderData($returnData));
    }
    
    /**
     * 準備訂單資料
     */
    private function prepareOrderData($orderData)
    {
        // 實際的資料準備邏輯
        // 應該與現有的 OrderController 邏輯保持一致
        return $orderData;
    }
}
```

### 3. 控制器擴展

#### OrderController 修改
```php
// 在 OrderController 中新增批量處理方法
public function storeBatch(Request $request)
{
    try {
        $validated = $request->validate([
            'date_mode' => 'required|in:single,multiple',
            'selected_dates' => 'required_if:date_mode,multiple|array|min:1|max:50',
            'selected_dates.*' => 'date|after:today',
            // ... 其他現有驗證規則
        ]);
        
        if ($validated['date_mode'] === 'single') {
            // 使用現有的單日建立邏輯
            return $this->store($request);
        }
        
        // 多日模式
        $batchService = new BatchOrderService($this->carpoolGroupService);
        $result = $batchService->createMultipleDaysOrders(
            $validated,
            $validated['selected_dates']
        );
        
        $message = "批量建立完成：成功 {$result['total_created']} 筆";
        if ($result['total_failed'] > 0) {
            $message .= "，失敗 {$result['total_failed']} 筆";
        }
        
        return redirect()->route('orders.index')->with('success', $message);
        
    } catch (\Exception $e) {
        return back()->withErrors(['batch_error' => $e->getMessage()])->withInput();
    }
}
```

### 4. 前端 JavaScript 實作

#### 多日期選擇器初始化
```javascript
class BatchOrderForm extends OrderForm {
    constructor() {
        super();
        this.selectedDates = [];
        this.initDatePicker();
        this.bindBatchEvents();
    }
    
    initDatePicker() {
        // 使用 Flatpickr 作為多日期選擇器
        this.datePicker = flatpickr("#multiple-date-picker", {
            mode: "multiple",
            dateFormat: "Y-m-d",
            minDate: "today",
            maxDate: new Date().fp_incr(180), // 6個月限制
            locale: "zh-tw",
            onChange: this.handleDateChange.bind(this)
        });
    }
    
    bindBatchEvents() {
        // 日期模式切換
        $('input[name="date_mode"]').on('change', this.handleModeChange.bind(this));
        
        // 預覽按鈕
        $('#preview-batch-btn').on('click', this.showBatchPreview.bind(this));
        
        // 建立批量訂單
        $('#create-batch-btn').on('click', this.createBatchOrders.bind(this));
    }
    
    handleModeChange(event) {
        const mode = event.target.value;
        
        if (mode === 'single') {
            $('#single-date-section').show();
            $('#multiple-dates-section').hide();
            $('#batch-preview-section').hide();
        } else {
            $('#single-date-section').hide();
            $('#multiple-dates-section').show();
        }
        
        this.updateFormAction(mode);
    }
    
    handleDateChange(selectedDates) {
        this.selectedDates = selectedDates.map(date => 
            date.toISOString().split('T')[0]
        );
        
        this.updateSelectedDatesList();
        this.updatePreviewButton();
    }
    
    updateSelectedDatesList() {
        const container = $('#selected-dates-list');
        
        if (this.selectedDates.length === 0) {
            container.html('<div class="text-muted">尚未選擇任何日期</div>');
            return;
        }
        
        const dateItems = this.selectedDates.map(date => `
            <span class="badge bg-secondary me-1 mb-1">
                ${date}
                <i class="fas fa-times ms-1 cursor-pointer" onclick="batchForm.removeDate('${date}')"></i>
            </span>
        `).join('');
        
        container.html(dateItems);
    }
    
    removeDate(dateToRemove) {
        this.selectedDates = this.selectedDates.filter(date => date !== dateToRemove);
        this.datePicker.setDate(this.selectedDates);
        this.updateSelectedDatesList();
        this.updatePreviewButton();
    }
    
    showBatchPreview() {
        if (this.selectedDates.length === 0) {
            alert('請先選擇日期');
            return;
        }
        
        // 驗證表單基本資料
        if (!this.validateBaseForm()) {
            return;
        }
        
        // 生成預覽內容
        this.generatePreviewTable();
        $('#batch-preview-section').show();
        
        // 滾動到預覽區域
        document.getElementById('batch-preview-section').scrollIntoView({
            behavior: 'smooth'
        });
    }
    
    generatePreviewTable() {
        const formData = this.getFormData();
        let tableHtml = `
            <table class="table table-sm">
                <thead>
                    <tr>
                        <th>日期</th>
                        <th>時間</th>
                        <th>客戶</th>
                        <th>上車地址</th>
                        <th>下車地址</th>
                        <th>共乘</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        this.selectedDates.forEach(date => {
            const isCarpool = formData.carpool_customer_id ? '是' : '否';
            tableHtml += `
                <tr>
                    <td>${date}</td>
                    <td>${formData.ride_time}</td>
                    <td>${formData.customer_name}</td>
                    <td>${formData.pickup_address}</td>
                    <td>${formData.dropoff_address}</td>
                    <td>${isCarpool}</td>
                </tr>
            `;
        });
        
        tableHtml += '</tbody></table>';
        
        $('#batch-orders-preview').html(tableHtml);
        $('#total-orders').text(this.selectedDates.length);
    }
    
    createBatchOrders() {
        // 準備表單資料
        const formData = this.getFormData();
        formData.date_mode = 'multiple';
        formData.selected_dates = this.selectedDates;
        
        // 顯示載入狀態
        this.showLoadingState();
        
        // 提交表單
        $.ajax({
            url: '/orders/batch',
            method: 'POST',
            data: formData,
            success: this.handleBatchSuccess.bind(this),
            error: this.handleBatchError.bind(this)
        });
    }
    
    showLoadingState() {
        $('#create-batch-btn').prop('disabled', true).html(`
            <i class="fas fa-spinner fa-spin me-2"></i>建立中...
        `);
    }
    
    handleBatchSuccess(response) {
        // 處理成功回應
        window.location.href = '/orders?success=' + encodeURIComponent(response.message);
    }
    
    handleBatchError(xhr) {
        // 處理錯誤
        const errors = xhr.responseJSON?.errors || {};
        this.displayErrors(errors);
        
        $('#create-batch-btn').prop('disabled', false).html(`
            <i class="fas fa-plus me-2"></i>建立批量訂單
        `);
    }
}

// 初始化
let batchForm;
$(document).ready(function() {
    batchForm = new BatchOrderForm();
});
```

## 記憶體和效能影響分析

### 記憶體影響評估

#### 單次批量操作記憶體使用
- **10 筆訂單**：約 24KB（單筆 2.4KB × 10）
- **25 筆訂單**：約 60KB（單筆 2.4KB × 25）  
- **50 筆訂單**：約 120KB（單筆 2.4KB × 50，建議上限）

#### 共乘訂單記憶體影響
- **10 筆共乘訂單**：約 48KB（雙倍記憶體，每組 4.8KB）
- **25 筆共乘訂單**：約 120KB
- **50 筆共乘訂單**：約 240KB

#### 前端記憶體考量
- **日期選擇器**：約 50-100KB（取決於日期範圍）
- **預覽表格**：約 10-50KB（取決於訂單數量）
- **進度追蹤**：約 5-10KB

### 效能最佳化策略

#### 後端最佳化
1. **分批處理**
```php
// 分批處理大量訂單，每批 10 筆
$batches = array_chunk($dates, 10);
foreach ($batches as $batch) {
    $this->processBatch($orderData, $batch);
    
    // 記憶體清理
    if (memory_get_usage() > 50 * 1024 * 1024) { // 50MB
        gc_collect_cycles();
    }
}
```

2. **資料庫最佳化**
```php
// 使用批量插入減少資料庫連線
Order::insert($orderDataArray);

// 使用事務確保資料一致性
DB::transaction(function () use ($orders) {
    Order::insert($orders);
});
```

3. **記憶體監控**
```php
class BatchMemoryMonitor
{
    public function monitor($operation, $callback)
    {
        $startMemory = memory_get_usage();
        $result = $callback();
        $endMemory = memory_get_usage();
        
        Log::info('批量操作記憶體使用', [
            'operation' => $operation,
            'memory_used' => $endMemory - $startMemory,
            'peak_memory' => memory_get_peak_usage()
        ]);
        
        return $result;
    }
}
```

#### 前端最佳化
1. **虛擬滾動**：預覽大量訂單時使用虛擬滾動
2. **延遲載入**：分頁載入預覽內容
3. **記憶體清理**：定期清理未使用的 DOM 元素

### 建議的限制和監控

#### 系統限制
- **單次最大訂單數**：50 筆
- **日期範圍限制**：最多 6 個月
- **併發限制**：同一用戶同時只能有一個批量操作
- **記憶體警告閾值**：單次操作超過 100MB 時記錄警告

#### 監控指標
- 批量操作的記憶體使用峰值
- 資料庫查詢執行時間
- 失敗率和錯誤類型統計
- 用戶操作模式分析

## 實施步驟和優先級

### 第一階段：核心功能（高優先級）
**目標**：實現基本的多日訂單建立功能

**任務清單**：
1. 建立 `BatchOrderService` 類別
2. 擴展 `OrderController` 支援批量模式
3. 前端日期選擇模式切換
4. 基本的多日期選擇器
5. 簡單的批量建立邏輯

**預估工時**：5-7 工作天

**驗收標準**：
- 能夠選擇多個日期
- 能夠為選擇的日期建立相同的訂單
- 基本的錯誤處理和驗證

### 第二階段：體驗優化（中優先級）
**目標**：完善使用者體驗和錯誤處理

**任務清單**：
1. 訂單預覽功能
2. 批量建立進度提示
3. 詳細的錯誤報告
4. 重複訂單檢查優化
5. 共乘功能整合

**預估工時**：3-5 工作天

**驗收標準**：
- 提供清晰的預覽介面
- 顯示建立進度和狀態
- 詳細的錯誤訊息和處理
- 支援共乘批量建立

### 第三階段：進階功能（低優先級）
**目標**：效能優化和進階功能

**任務清單**：
1. `batch_id` 欄位和相關功能
2. 記憶體使用優化
3. 失敗訂單重試機制
4. 批量操作統計和監控
5. 使用者操作記錄

**預估工時**：2-3 工作天

**驗收標準**：
- 系統效能穩定
- 完整的監控和統計
- 高級錯誤恢復機制

## 風險評估和緩解策略

### 技術風險

#### 1. 記憶體溢出風險
**風險描述**：大量訂單建立可能導致記憶體不足

**緩解策略**：
- 實施單次最大 50 筆訂單限制
- 使用分批處理機制
- 實時記憶體監控和警告
- 在記憶體使用過高時自動分批處理

#### 2. 資料庫效能風險
**風險描述**：批量插入可能影響資料庫效能

**緩解策略**：
- 使用資料庫事務確保一致性
- 實施連線池管理
- 避開業務高峰期進行大批量操作
- 資料庫查詢優化和索引調整

#### 3. 併發操作風險
**風險描述**：多用戶同時進行批量操作可能導致系統不穩定

**緩解策略**：
- 實施用戶級別的操作鎖定
- 限制同時進行的批量操作數量
- 使用佇列機制處理大量請求
- 實施請求速率限制

### 業務風險

#### 1. 誤操作風險
**風險描述**：用戶可能誤建立大量錯誤訂單

**緩解策略**：
- 提供詳細的預覽確認功能
- 實施兩步驟確認機制
- 提供批量刪除功能（管理員）
- 操作記錄和審計追蹤

#### 2. 學習成本風險
**風險描述**：新功能可能增加用戶學習成本

**緩解策略**：
- 設計直觀的用戶介面
- 提供操作指引和幫助文檔
- 保留原有單日建立功能
- 提供用戶培訓和支援

## 測試策略

### 單元測試
- `BatchOrderService` 類別方法測試
- 日期驗證邏輯測試
- 重複訂單檢查測試
- 記憶體使用測試

### 整合測試
- 前後端整合測試
- 資料庫事務測試
- 共乘功能整合測試
- 錯誤處理流程測試

### 效能測試
- 大量訂單建立效能測試
- 記憶體使用壓力測試
- 併發操作測試
- 資料庫效能測試

### 使用者測試
- 介面易用性測試
- 工作流程測試
- 錯誤情境測試
- 用戶接受度測試

## 部署和維護

### 部署準備
1. **資料庫遷移**：新增必要的欄位和索引
2. **前端資源**：更新 JavaScript 和 CSS 檔案
3. **設定檔案**：調整系統限制和監控參數
4. **文檔更新**：更新用戶手冊和 API 文檔

### 監控設定
1. **效能監控**：設定記憶體和 CPU 使用警告
2. **錯誤監控**：設定錯誤率和失敗次數警告
3. **業務監控**：設定批量操作使用統計
4. **安全監控**：設定異常操作檢測

### 維護計劃
1. **定期檢查**：每週檢查系統效能和錯誤日誌
2. **優化調整**：根據使用情況調整限制和參數
3. **功能更新**：根據用戶反饋持續改進功能
4. **文檔維護**：保持文檔和幫助資訊的更新

## 結論

多天訂單建立功能將大幅提升系統的使用效率，減少重複操作，改善用戶體驗。通過分階段實施、完善的測試策略、以及持續的監控和優化，可以確保功能的穩定性和可靠性。

建議優先實施第一階段的核心功能，在穩定運行後再逐步添加進階功能。同時需要密切關注系統效能和用戶反饋，持續優化和改進功能。

---

**文檔版本**：1.0  
**建立日期**：2025-08-02  
**最後更新**：2025-08-02  
**負責人**：開發團隊  
**審核人**：專案經理