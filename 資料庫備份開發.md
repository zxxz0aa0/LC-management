# 資料庫備份開發規劃

## 文件資訊
- **專案名稱**: LC-management (長照服務管理系統)
- **資料庫**: MySQL (透過 XAMPP)
- **框架**: Laravel 10.x
- **環境**: Windows + XAMPP
- **建立日期**: 2025-11-03
- **版本**: 1.0

---

## 1. 備份策略概覽

### 1.1 備份目標
- **資料完整性**: 確保所有關鍵業務資料可完整備份
- **快速復原**: 提供快速還原機制,最小化系統停機時間
- **版本管理**: 保留多個備份版本,支援時間點還原
- **安全性**: 備份檔案加密存儲,防止資料外洩

### 1.2 備份頻率
| 備份類型 | 執行頻率 | 保留期限 | 說明 |
|---------|---------|---------|------|
| 完整備份 | 每日凌晨 2:00 | 30 天 | 完整資料庫備份 |
| 週備份 | 每週日凌晨 3:00 | 12 週 (3個月) | 週度長期保存 |
| 月備份 | 每月 1 號凌晨 4:00 | 12 個月 (1年) | 月度長期保存 |
| 手動備份 | 依需求執行 | 永久保存 | 重大更新前手動備份 |

### 1.3 備份保留政策
```
storage/backups/
├── daily/          # 每日備份 (保留 30 天)
│   ├── lc_management_2025_11_01_020000.sql.gz
│   ├── lc_management_2025_11_02_020000.sql.gz
│   └── lc_management_2025_11_03_020000.sql.gz
├── weekly/         # 每週備份 (保留 12 週)
│   ├── lc_management_week_44_2025.sql.gz
│   └── lc_management_week_45_2025.sql.gz
├── monthly/        # 每月備份 (保留 12 個月)
│   ├── lc_management_2025_09.sql.gz
│   └── lc_management_2025_10.sql.gz
└── manual/         # 手動備份 (永久保存)
    ├── lc_management_before_v2_migration.sql.gz
    └── lc_management_before_carpool_feature.sql.gz
```

---

## 2. 備份內容與範圍

### 2.1 完整備份 (Full Backup)
備份所有資料表和資料,包含:

#### 核心業務資料表
- `orders` - 訂單資料 (含共乘群組資訊)
- `order_sequences` - 訂單序列號表 (併發控制關鍵表)
- `customers` - 客戶資料 (含 JSON 欄位)
- `drivers` - 司機資料
- `landmarks` - 地標資料

#### 系統與認證資料表
- `users` - 使用者帳號
- `password_reset_tokens` - 密碼重設權杖
- `personal_access_tokens` - API 權杖
- `sessions` - 使用者 Session

#### 歷史與追蹤資料表
- `customer_events` - 客戶事件記錄
- `import_sessions` - 匯入工作階段
- `import_progresses` - 匯入進度記錄

#### 佇列與任務資料表
- `jobs` - 待執行佇列任務
- `failed_jobs` - 失敗任務記錄

### 2.2 關鍵表單獨備份
對於資料變更頻繁且關鍵的表,額外建立單獨備份:

```bash
# 訂單表單獨備份 (每日多次)
mysqldump --single-transaction lc_management orders > orders_backup.sql

# 客戶表單獨備份
mysqldump --single-transaction lc_management customers > customers_backup.sql

# 司機表單獨備份
mysqldump --single-transaction lc_management drivers > drivers_backup.sql
```

### 2.3 結構備份 (Schema Only)
僅備份資料庫結構,不含資料,用於開發環境快速建立:

```bash
mysqldump --no-data lc_management > schema_only.sql
```

### 2.4 測試資料備份 (不含敏感資訊)
移除敏感欄位後的備份,用於測試環境:

```sql
-- 客戶資料去敏感化
UPDATE customers SET
    id_number = CONCAT('A', LPAD(id, 9, '0')),
    phones = JSON_ARRAY(CONCAT('0900', LPAD(id, 6, '0'))),
    addresses = JSON_ARRAY('測試地址');

-- 司機資料去敏感化
UPDATE drivers SET
    phone = CONCAT('0900', LPAD(id, 6, '0')),
    license_plate = CONCAT('ABC-', LPAD(id, 4, '0'));
```

---

## 3. 技術實作方案

### 3.1 Laravel Artisan 備份命令

由於篇幅較長,完整的 Laravel Artisan 命令程式碼請參考以下結構:

#### 建立備份命令
位置: `app/Console/Commands/DatabaseBackup.php`

**主要功能**:
- 支援完整備份、結構備份、指定表備份
- 自動壓縮備份檔案 (gzip)
- 可選加密功能
- 自動清理過期備份

#### 建立還原命令
位置: `app/Console/Commands/DatabaseRestore.php`

**主要功能**:
- 從備份檔案還原資料庫
- 自動解壓縮 .gz 檔案
- 還原前確認機制

### 3.2 排程任務設定

#### Laravel Task Scheduling
在 `app/Console/Kernel.php` 中設定:

```php
protected function schedule(Schedule $schedule)
{
    // 每日完整備份 (凌晨 2:00)
    $schedule->command('db:backup --type=full --compress')
             ->dailyAt('02:00')
             ->withoutOverlapping()           // 防止重疊執行
             ->runInBackground()              // 背景執行
             ->emailOutputOnFailure('admin@example.com')  // 失敗時發送郵件
             ->onSuccess(function () {
                 Log::info('Daily database backup completed successfully');
             })
             ->onFailure(function () {
                 Log::error('Daily database backup failed');
                 // 可在此處加入 Slack 通知或其他警報機制
             });

    // 每週備份 (週日凌晨 3:00)
    $schedule->command('db:backup --type=full --compress')
             ->weeklyOn(0, '03:00')
             ->withoutOverlapping()
             ->runInBackground()
             ->emailOutputOnFailure('admin@example.com');

    // 每月備份 (每月 1 號凌晨 4:00)
    $schedule->command('db:backup --type=full --compress')
             ->monthlyOn(1, '04:00')
             ->withoutOverlapping()
             ->runInBackground()
             ->emailOutputOnFailure('admin@example.com');

    // 關鍵表額外備份 (每 4 小時)
    // 針對 orders、order_sequences、customers、drivers 進行高頻備份
    $schedule->command('db:backup --type=tables --tables=orders,order_sequences,customers,drivers --compress')
             ->cron('0 */4 * * *')  // 每 4 小時執行
             ->withoutOverlapping()
             ->runInBackground();

    // 備份狀態監控 (每小時)
    $schedule->command('db:monitor-backups')
             ->hourly()
             ->withoutOverlapping();

    // 每日備份報告 (每天早上 9:00)
    $schedule->command('db:monitor-backups --report')
             ->dailyAt('09:00')
             ->emailOutputTo('admin@example.com');
}
```

**重要提醒**:
- `withoutOverlapping()` 需要 cache driver 支援，建議使用 Redis
- 若使用檔案快取，確保 `storage/framework/cache` 目錄可寫入
- 排程任務需要設定 Cron (Linux) 或 Task Scheduler (Windows):

```bash
# Linux Cron 設定
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1
```

```batch
# Windows Task Scheduler（每分鐘執行）
php C:\xampp\htdocs\LC-management\artisan schedule:run
```

#### Windows Task Scheduler 設定
針對 XAMPP 環境,使用 Windows 工作排程器:

**⚠️ 密碼安全設定（必須先完成）**

為了避免密碼明碼暴露，請先建立 MySQL 配置檔：

**方案 1: 使用 MySQL 配置檔（推薦）**
建立檔案 `C:\xampp\mysql\bin\my_backup.cnf`:
```ini
[client]
user=root
password=你的MySQL密碼
host=localhost
```

設定檔案權限（僅限當前使用者存取）:
```batch
icacls "C:\xampp\mysql\bin\my_backup.cnf" /inheritance:r /grant:r "%USERNAME%:(R)"
```

**方案 2: 使用環境變數**
在系統環境變數中設定（不建議用於生產環境）:
```batch
setx MYSQL_PWD "你的MySQL密碼"
```

---

**建立批次腳本**: `database_backup.bat`
```batch
@echo off
REM ============================================
REM LC-management 資料庫備份腳本（安全強化版）
REM 請將此檔案放置於專案根目錄
REM ============================================

setlocal EnableDelayedExpansion

REM 配置參數
set BACKUP_DIR=C:\xampp\htdocs\LC-management\storage\backups\daily
set DB_NAME=lc_management
set MYSQL_BIN=C:\xampp\mysql\bin
set MYSQL_CNF=%MYSQL_BIN%\my_backup.cnf
set SEVEN_ZIP=C:\Program Files\7-Zip\7z.exe
set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%
set TIMESTAMP=%TIMESTAMP: =0%
set BACKUP_FILE=%BACKUP_DIR%\%DB_NAME%_%TIMESTAMP%.sql
set LOG_FILE=%BACKUP_DIR%\backup.log

REM ============================================
REM 前置檢查
REM ============================================

REM 檢查 mysqldump 是否存在
if not exist "%MYSQL_BIN%\mysqldump.exe" (
    echo [ERROR] mysqldump not found at %MYSQL_BIN% >> "%LOG_FILE%"
    echo ERROR: mysqldump not found
    exit /b 1
)

REM 檢查配置檔是否存在
if not exist "%MYSQL_CNF%" (
    echo [ERROR] MySQL config file not found: %MYSQL_CNF% >> "%LOG_FILE%"
    echo ERROR: MySQL config file not found. Please create %MYSQL_CNF%
    exit /b 1
)

REM 檢查 7-Zip 是否存在
if not exist "%SEVEN_ZIP%" (
    echo [WARNING] 7-Zip not found, backup will not be compressed >> "%LOG_FILE%"
    echo WARNING: 7-Zip not found, backup will not be compressed
    set COMPRESS=0
) else (
    set COMPRESS=1
)

REM 確保備份目錄存在
if not exist "%BACKUP_DIR%" (
    mkdir "%BACKUP_DIR%"
    if !ERRORLEVEL! neq 0 (
        echo [ERROR] Failed to create backup directory >> "%LOG_FILE%"
        echo ERROR: Failed to create backup directory
        exit /b 1
    )
)

REM 檢查磁碟空間（至少需要 500MB）
for /f "tokens=3" %%a in ('dir /-c "%BACKUP_DIR%" ^| find "bytes free"') do set FREE_SPACE=%%a
if !FREE_SPACE! LSS 500000000 (
    echo [ERROR] Insufficient disk space: !FREE_SPACE! bytes free >> "%LOG_FILE%"
    echo ERROR: Insufficient disk space
    exit /b 1
)

echo [INFO] Starting backup at %date% %time% >> "%LOG_FILE%"
echo Starting database backup...

REM ============================================
REM 執行備份
REM ============================================

cd /d "%MYSQL_BIN%"
mysqldump --defaults-file="%MYSQL_CNF%" ^
    --single-transaction ^
    --set-gtid-purged=OFF ^
    --skip-lock-tables ^
    --routines ^
    --triggers ^
    --events ^
    %DB_NAME% > "%BACKUP_FILE%" 2>> "%LOG_FILE%"

if !ERRORLEVEL! neq 0 (
    echo [ERROR] mysqldump failed with error code !ERRORLEVEL! >> "%LOG_FILE%"
    echo ERROR: Backup failed
    if exist "%BACKUP_FILE%" del "%BACKUP_FILE%"
    exit /b !ERRORLEVEL!
)

REM 驗證備份檔案是否建立且非空
if not exist "%BACKUP_FILE%" (
    echo [ERROR] Backup file was not created >> "%LOG_FILE%"
    echo ERROR: Backup file was not created
    exit /b 1
)

for %%A in ("%BACKUP_FILE%") do set FILE_SIZE=%%~zA
if !FILE_SIZE! LSS 1000 (
    echo [ERROR] Backup file is too small: !FILE_SIZE! bytes >> "%LOG_FILE%"
    echo ERROR: Backup file is suspiciously small
    exit /b 1
)

echo [INFO] Backup file created: %BACKUP_FILE% (!FILE_SIZE! bytes) >> "%LOG_FILE%"
echo Backup completed: !FILE_SIZE! bytes

REM ============================================
REM 壓縮備份檔案
REM ============================================

if !COMPRESS! equ 1 (
    echo Compressing backup file...
    "%SEVEN_ZIP%" a -tgzip -mx=9 "%BACKUP_FILE%.gz" "%BACKUP_FILE%" > nul 2>&1

    if !ERRORLEVEL! equ 0 (
        REM 壓縮成功，刪除原始檔案
        del "%BACKUP_FILE%"
        echo [INFO] Backup compressed: %BACKUP_FILE%.gz >> "%LOG_FILE%"
        echo Backup compressed successfully
        set FINAL_FILE=%BACKUP_FILE%.gz
    ) else (
        echo [WARNING] Compression failed, keeping original file >> "%LOG_FILE%"
        echo WARNING: Compression failed, keeping original file
        set FINAL_FILE=%BACKUP_FILE%
    )
) else (
    set FINAL_FILE=%BACKUP_FILE%
)

REM ============================================
REM 清理舊備份
REM ============================================

echo Cleaning up old backups...
forfiles /p "%BACKUP_DIR%" /m *.sql* /d -30 /c "cmd /c del @path" 2>nul
if !ERRORLEVEL! equ 0 (
    echo [INFO] Old backups cleaned up >> "%LOG_FILE%"
) else (
    echo [INFO] No old backups to clean >> "%LOG_FILE%"
)

REM ============================================
REM 完成
REM ============================================

echo [INFO] Backup completed successfully at %date% %time% >> "%LOG_FILE%"
echo ============================================
echo Backup completed successfully!
echo File: !FINAL_FILE!
echo ============================================

exit /b 0
```

**設定 Windows 工作排程器**:
```powershell
# 使用 PowerShell 建立排程任務
$action = New-ScheduledTaskAction -Execute "C:\xampp\htdocs\LC-management\database_backup.bat"
$trigger = New-ScheduledTaskTrigger -Daily -At 2am
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -DontStopIfGoingOnBatteries

Register-ScheduledTask -TaskName "LC-Management Daily Backup" -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Description "每日資料庫備份"
```

### 3.3 備份腳本集合

#### 快速備份腳本 (quick_backup.bat)
```batch
@echo off
REM ============================================
REM 快速手動備份腳本（安全強化版）
REM ============================================

setlocal EnableDelayedExpansion

set DB_NAME=lc_management
set MYSQL_BIN=C:\xampp\mysql\bin
set MYSQL_CNF=%MYSQL_BIN%\my_backup.cnf
set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%
set TIMESTAMP=%TIMESTAMP: =0%
set BACKUP_FILE=C:\xampp\htdocs\LC-management\storage\backups\manual\%DB_NAME%_manual_%TIMESTAMP%.sql

REM 檢查配置檔
if not exist "%MYSQL_CNF%" (
    echo ERROR: MySQL config file not found: %MYSQL_CNF%
    echo Please create the config file first.
    pause
    exit /b 1
)

REM 確保備份目錄存在
if not exist "C:\xampp\htdocs\LC-management\storage\backups\manual" (
    mkdir "C:\xampp\htdocs\LC-management\storage\backups\manual"
)

echo Starting manual backup...
cd /d "%MYSQL_BIN%"
mysqldump --defaults-file="%MYSQL_CNF%" --single-transaction --set-gtid-purged=OFF %DB_NAME% > "%BACKUP_FILE%"

if !ERRORLEVEL! neq 0 (
    echo ERROR: Backup failed
    pause
    exit /b !ERRORLEVEL!
)

REM 驗證備份檔案
if not exist "%BACKUP_FILE%" (
    echo ERROR: Backup file was not created
    pause
    exit /b 1
)

for %%A in ("%BACKUP_FILE%") do set FILE_SIZE=%%~zA
echo ============================================
echo Manual backup completed successfully!
echo File: %BACKUP_FILE%
echo Size: !FILE_SIZE! bytes
echo ============================================
pause
exit /b 0
```

#### 結構備份腳本 (schema_backup.bat)
```batch
@echo off
REM ============================================
REM 僅備份資料庫結構（安全強化版）
REM ============================================

setlocal EnableDelayedExpansion

set DB_NAME=lc_management
set MYSQL_BIN=C:\xampp\mysql\bin
set MYSQL_CNF=%MYSQL_BIN%\my_backup.cnf
set SCHEMA_FILE=C:\xampp\htdocs\LC-management\storage\backups\schema_only.sql

REM 檢查配置檔
if not exist "%MYSQL_CNF%" (
    echo ERROR: MySQL config file not found: %MYSQL_CNF%
    pause
    exit /b 1
)

echo Starting schema backup...
cd /d "%MYSQL_BIN%"
mysqldump --defaults-file="%MYSQL_CNF%" --no-data --routines --triggers --events %DB_NAME% > "%SCHEMA_FILE%"

if !ERRORLEVEL! neq 0 (
    echo ERROR: Schema backup failed
    pause
    exit /b !ERRORLEVEL!
)

if not exist "%SCHEMA_FILE%" (
    echo ERROR: Schema file was not created
    pause
    exit /b 1
)

for %%A in ("%SCHEMA_FILE%") do set FILE_SIZE=%%~zA
echo ============================================
echo Schema backup completed successfully!
echo File: %SCHEMA_FILE%
echo Size: !FILE_SIZE! bytes
echo ============================================
pause
exit /b 0
```

#### 關鍵表備份腳本 (critical_tables_backup.bat)
```batch
@echo off
REM ============================================
REM 備份關鍵業務資料表（安全強化版）
REM 包含：orders, order_sequences, customers, drivers
REM ============================================

setlocal EnableDelayedExpansion

set DB_NAME=lc_management
set MYSQL_BIN=C:\xampp\mysql\bin
set MYSQL_CNF=%MYSQL_BIN%\my_backup.cnf
set BACKUP_DIR=C:\xampp\htdocs\LC-management\storage\backups\critical
set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%
set TIMESTAMP=%TIMESTAMP: =0%

REM 檢查配置檔
if not exist "%MYSQL_CNF%" (
    echo ERROR: MySQL config file not found: %MYSQL_CNF%
    pause
    exit /b 1
)

REM 確保備份目錄存在
if not exist "%BACKUP_DIR%" mkdir "%BACKUP_DIR%"

echo Starting critical tables backup...
cd /d "%MYSQL_BIN%"

REM 備份訂單表（最重要）
echo Backing up orders table...
mysqldump --defaults-file="%MYSQL_CNF%" --single-transaction --set-gtid-purged=OFF %DB_NAME% orders > "%BACKUP_DIR%\orders_%TIMESTAMP%.sql"
if !ERRORLEVEL! neq 0 (
    echo ERROR: Failed to backup orders table
    pause
    exit /b 1
)

REM 備份訂單序列表（併發控制關鍵）
echo Backing up order_sequences table...
mysqldump --defaults-file="%MYSQL_CNF%" --single-transaction --set-gtid-purged=OFF %DB_NAME% order_sequences > "%BACKUP_DIR%\order_sequences_%TIMESTAMP%.sql"
if !ERRORLEVEL! neq 0 (
    echo WARNING: Failed to backup order_sequences table
)

REM 備份客戶表
echo Backing up customers table...
mysqldump --defaults-file="%MYSQL_CNF%" --single-transaction --set-gtid-purged=OFF %DB_NAME% customers > "%BACKUP_DIR%\customers_%TIMESTAMP%.sql"
if !ERRORLEVEL! neq 0 (
    echo WARNING: Failed to backup customers table
)

REM 備份司機表
echo Backing up drivers table...
mysqldump --defaults-file="%MYSQL_CNF%" --single-transaction --set-gtid-purged=OFF %DB_NAME% drivers > "%BACKUP_DIR%\drivers_%TIMESTAMP%.sql"
if !ERRORLEVEL! neq 0 (
    echo WARNING: Failed to backup drivers table
)

REM 清理超過 7 天的關鍵表備份
echo Cleaning up old critical backups...
forfiles /p "%BACKUP_DIR%" /m *.sql /d -7 /c "cmd /c del @path" 2>nul

echo ============================================
echo Critical tables backup completed!
echo Location: %BACKUP_DIR%
echo Timestamp: %TIMESTAMP%
echo ============================================
pause
exit /b 0
```

---

## 4. Laravel Artisan 命令實作

本章提供完整的 Laravel Artisan 命令程式碼，可直接使用於專案中。

### 4.1 DatabaseBackup 命令

位置: `app/Console/Commands/DatabaseBackup.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class DatabaseBackup extends Command
{
    protected $signature = 'db:backup
                            {--type=full : Backup type (full|schema|tables)}
                            {--tables= : Comma-separated table names (for type=tables)}
                            {--compress : Compress backup file with gzip}
                            {--encrypt : Encrypt backup file (not recommended without proper key management)}
                            {--output-dir=storage/backups/daily : Output directory}';

    protected $description = 'Create a database backup';

    public function handle()
    {
        $type = $this->option('type');
        $compress = $this->option('compress');
        $outputDir = base_path($this->option('output-dir'));

        $this->info('Starting database backup...');
        $this->info('Type: ' . $type);
        $this->info('Compress: ' . ($compress ? 'Yes' : 'No'));

        // 確保輸出目錄存在
        if (!File::exists($outputDir)) {
            File::makeDirectory($outputDir, 0700, true);
            $this->info('Created output directory: ' . $outputDir);
        }

        // 檢查磁碟空間
        if (!$this->checkDiskSpace($outputDir)) {
            $this->error('Insufficient disk space!');
            return 1;
        }

        // 生成備份檔案名稱
        $timestamp = now()->format('Y_m_d_His');
        $dbName = config('database.connections.mysql.database');
        $filename = "{$dbName}_{$type}_{$timestamp}.sql";
        $filepath = $outputDir . DIRECTORY_SEPARATOR . $filename;

        try {
            // 執行備份
            $this->performBackup($type, $filepath);

            // 驗證備份檔案
            if (!File::exists($filepath)) {
                throw new \Exception('Backup file was not created');
            }

            $fileSize = File::size($filepath);
            if ($fileSize < 1000) {
                throw new \Exception('Backup file is suspiciously small: ' . $fileSize . ' bytes');
            }

            $this->info('Backup completed: ' . $filename);
            $this->info('File size: ' . $this->formatBytes($fileSize));

            // 壓縮
            if ($compress) {
                $this->compressFile($filepath);
            }

            // 記錄日誌
            Log::info('Database backup completed', [
                'type' => $type,
                'file' => $filename,
                'size' => $fileSize,
                'compressed' => $compress,
            ]);

            $this->info('✓ Backup successful!');
            return 0;

        } catch (\Exception $e) {
            $this->error('Backup failed: ' . $e->getMessage());
            Log::error('Database backup failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            // 清理失敗的備份檔案
            if (File::exists($filepath)) {
                File::delete($filepath);
            }

            return 1;
        }
    }

    protected function performBackup(string $type, string $filepath): void
    {
        $dbHost = config('database.connections.mysql.host');
        $dbPort = config('database.connections.mysql.port');
        $dbName = config('database.connections.mysql.database');
        $dbUser = config('database.connections.mysql.username');
        $dbPass = config('database.connections.mysql.password');

        // 建立臨時配置檔（安全處理密碼）
        $configFile = $this->createTempConfigFile($dbUser, $dbPass);

        try {
            $command = sprintf(
                'mysqldump --defaults-file=%s --host=%s --port=%s --single-transaction --set-gtid-purged=OFF --skip-lock-tables --routines --triggers --events',
                escapeshellarg($configFile),
                escapeshellarg($dbHost),
                escapeshellarg($dbPort)
            );

            // 根據類型調整命令
            switch ($type) {
                case 'schema':
                    $command .= ' --no-data';
                    break;
                case 'tables':
                    $tables = $this->option('tables');
                    if (!$tables) {
                        throw new \InvalidArgumentException('--tables option is required for type=tables');
                    }
                    $tableList = explode(',', $tables);
                    foreach ($tableList as $table) {
                        $command .= ' ' . escapeshellarg(trim($table));
                    }
                    break;
            }

            $command .= ' ' . escapeshellarg($dbName);
            $command .= ' > ' . escapeshellarg($filepath);
            $command .= ' 2>&1';

            $this->line('Executing backup...');
            $output = [];
            $returnCode = 0;
            exec($command, $output, $returnCode);

            if ($returnCode !== 0) {
                throw new \RuntimeException('mysqldump failed with code ' . $returnCode . ': ' . implode("\n", $output));
            }

        } finally {
            // 清理臨時配置檔
            if (File::exists($configFile)) {
                File::delete($configFile);
            }
        }
    }

    protected function createTempConfigFile(string $user, string $password): string
    {
        $configFile = storage_path('app/temp_mysql_' . uniqid() . '.cnf');
        $content = "[client]\n";
        $content .= "user={$user}\n";
        $content .= "password=\"{$password}\"\n";

        File::put($configFile, $content);
        chmod($configFile, 0600);  // 僅限當前使用者讀取

        return $configFile;
    }

    protected function compressFile(string $filepath): void
    {
        $this->info('Compressing backup file...');

        $command = sprintf('gzip -9 %s', escapeshellarg($filepath));
        exec($command, $output, $returnCode);

        if ($returnCode === 0 && File::exists($filepath . '.gz')) {
            $this->info('Compression completed: ' . basename($filepath) . '.gz');
        } else {
            $this->warn('Compression failed, keeping original file');
        }
    }

    protected function checkDiskSpace(string $directory): bool
    {
        $freeSpace = disk_free_space($directory);
        $requiredSpace = 500 * 1024 * 1024; // 500 MB

        return $freeSpace >= $requiredSpace;
    }

    protected function formatBytes(int $bytes, int $precision = 2): string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);

        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
```

### 4.2 DatabaseRestore 命令

位置: `app/Console/Commands/DatabaseRestore.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

class DatabaseRestore extends Command
{
    protected $signature = 'db:restore
                            {backup-file : Path to backup file}
                            {--force : Skip confirmation prompt}
                            {--test-connection : Test database connection before restoring}';

    protected $description = 'Restore database from backup file';

    public function handle()
    {
        $backupFile = $this->argument('backup-file');
        $force = $this->option('force');

        // 驗證備份檔案
        if (!File::exists($backupFile)) {
            $this->error('Backup file not found: ' . $backupFile);
            return 1;
        }

        $this->info('Backup file: ' . $backupFile);
        $this->info('File size: ' . $this->formatBytes(File::size($backupFile)));

        // 測試資料庫連線
        if ($this->option('test-connection')) {
            try {
                DB::connection()->getPdo();
                $this->info('✓ Database connection successful');
            } catch (\Exception $e) {
                $this->error('Database connection failed: ' . $e->getMessage());
                return 1;
            }
        }

        // 確認提示
        if (!$force) {
            $dbName = config('database.connections.mysql.database');
            $this->warn('WARNING: This will overwrite the current database: ' . $dbName);
            $this->warn('All existing data will be replaced with the backup data.');

            if (!$this->confirm('Do you want to continue?')) {
                $this->info('Restore cancelled.');
                return 0;
            }

            // 二次確認
            if (!$this->confirm('Are you absolutely sure? This action cannot be undone!')) {
                $this->info('Restore cancelled.');
                return 0;
            }
        }

        try {
            $this->info('Starting database restore...');

            // 處理壓縮檔案
            $sqlFile = $this->handleCompressedFile($backupFile);

            // 執行還原
            $this->performRestore($sqlFile);

            // 清理臨時檔案
            if ($sqlFile !== $backupFile && File::exists($sqlFile)) {
                File::delete($sqlFile);
            }

            $this->info('✓ Database restore completed successfully!');

            // 建議執行的後續檢查
            $this->info('');
            $this->info('Recommended post-restore checks:');
            $this->line('  php artisan migrate:status');
            $this->line('  php artisan optimize:clear');
            $this->line('  php artisan tinker (check record counts)');

            Log::info('Database restore completed', ['file' => $backupFile]);
            return 0;

        } catch (\Exception $e) {
            $this->error('Restore failed: ' . $e->getMessage());
            Log::error('Database restore failed', [
                'file' => $backupFile,
                'error' => $e->getMessage(),
            ]);
            return 1;
        }
    }

    protected function handleCompressedFile(string $backupFile): string
    {
        if (substr($backupFile, -3) === '.gz') {
            $this->info('Decompressing backup file...');
            $sqlFile = substr($backupFile, 0, -3);

            $command = sprintf('gunzip -c %s > %s', escapeshellarg($backupFile), escapeshellarg($sqlFile));
            exec($command, $output, $returnCode);

            if ($returnCode !== 0 || !File::exists($sqlFile)) {
                throw new \RuntimeException('Failed to decompress backup file');
            }

            return $sqlFile;
        }

        return $backupFile;
    }

    protected function performRestore(string $sqlFile): void
    {
        $dbHost = config('database.connections.mysql.host');
        $dbPort = config('database.connections.mysql.port');
        $dbName = config('database.connections.mysql.database');
        $dbUser = config('database.connections.mysql.username');
        $dbPass = config('database.connections.mysql.password');

        // 建立臨時配置檔
        $configFile = $this->createTempConfigFile($dbUser, $dbPass);

        try {
            $command = sprintf(
                'mysql --defaults-file=%s --host=%s --port=%s %s < %s 2>&1',
                escapeshellarg($configFile),
                escapeshellarg($dbHost),
                escapeshellarg($dbPort),
                escapeshellarg($dbName),
                escapeshellarg($sqlFile)
            );

            $bar = $this->output->createProgressBar(100);
            $bar->start();

            $output = [];
            $returnCode = 0;
            exec($command, $output, $returnCode);

            $bar->finish();
            $this->newLine();

            if ($returnCode !== 0) {
                throw new \RuntimeException('mysql restore failed: ' . implode("\n", $output));
            }

        } finally {
            if (File::exists($configFile)) {
                File::delete($configFile);
            }
        }
    }

    protected function createTempConfigFile(string $user, string $password): string
    {
        $configFile = storage_path('app/temp_mysql_' . uniqid() . '.cnf');
        $content = "[client]\n";
        $content .= "user={$user}\n";
        $content .= "password=\"{$password}\"\n";

        File::put($configFile, $content);
        chmod($configFile, 0600);

        return $configFile;
    }

    protected function formatBytes(int $bytes, int $precision = 2): string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);

        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
```

### 4.3 VerifyBackup 命令

位置: `app/Console/Commands/VerifyBackup.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;

class VerifyBackup extends Command
{
    protected $signature = 'db:verify-backup
                            {backup-file : Path to backup file to verify}
                            {--detailed : Show detailed verification results}';

    protected $description = 'Verify backup file integrity and structure';

    protected $requiredTables = [
        'users',
        'orders',
        'order_sequences',
        'customers',
        'drivers',
        'landmarks',
    ];

    public function handle()
    {
        $backupFile = $this->argument('backup-file');
        $detailed = $this->option('detailed');

        $this->info('Verifying backup file: ' . $backupFile);
        $this->newLine();

        $checks = [
            'File Existence' => $this->checkFileExists($backupFile),
            'File Size' => $this->checkFileSize($backupFile),
            'File Readability' => $this->checkFileReadable($backupFile),
            'SQL Structure' => $this->checkSqlStructure($backupFile),
            'Required Tables' => $this->checkRequiredTables($backupFile, $detailed),
        ];

        // 顯示結果
        $this->newLine();
        $this->info('=== Verification Results ===');
        $allPassed = true;

        foreach ($checks as $check => $result) {
            $status = $result['passed'] ? '✓' : '✗';
            $color = $result['passed'] ? 'green' : 'red';

            $this->line("<fg={$color}>{$status} {$check}: {$result['message']}</>");

            if (!$result['passed']) {
                $allPassed = false;
            }
        }

        $this->newLine();
        if ($allPassed) {
            $this->info('✓ All checks passed! Backup file is valid.');
            return 0;
        } else {
            $this->error('✗ Some checks failed. Please review the backup file.');
            return 1;
        }
    }

    protected function checkFileExists(string $file): array
    {
        $exists = File::exists($file);
        return [
            'passed' => $exists,
            'message' => $exists ? 'File found' : 'File not found',
        ];
    }

    protected function checkFileSize(string $file): array
    {
        if (!File::exists($file)) {
            return ['passed' => false, 'message' => 'File not found'];
        }

        $size = File::size($file);
        $minSize = 1000; // 1 KB
        $maxSize = 10 * 1024 * 1024 * 1024; // 10 GB

        $passed = $size >= $minSize && $size <= $maxSize;
        $message = $this->formatBytes($size);

        if (!$passed) {
            if ($size < $minSize) {
                $message .= ' (too small)';
            } else {
                $message .= ' (too large)';
            }
        }

        return [
            'passed' => $passed,
            'message' => $message,
        ];
    }

    protected function checkFileReadable(string $file): array
    {
        if (!File::exists($file)) {
            return ['passed' => false, 'message' => 'File not found'];
        }

        $readable = is_readable($file);
        return [
            'passed' => $readable,
            'message' => $readable ? 'File is readable' : 'File is not readable',
        ];
    }

    protected function checkSqlStructure(string $file): array
    {
        if (!File::exists($file)) {
            return ['passed' => false, 'message' => 'File not found'];
        }

        try {
            // 處理壓縮檔案
            $content = $this->readFileContent($file);

            // 檢查 SQL 檔案的基本結構
            $hasCreateTable = strpos($content, 'CREATE TABLE') !== false;
            $hasInsert = strpos($content, 'INSERT INTO') !== false || strpos($content, '--no-data') !== false;
            $hasMySQLDump = strpos($content, 'MySQL dump') !== false;

            $passed = $hasCreateTable && $hasMySQLDump;
            $details = [];

            if (!$hasCreateTable) $details[] = 'No CREATE TABLE statements';
            if (!$hasMySQLDump) $details[] = 'Not a mysqldump file';

            $message = $passed ? 'Valid SQL structure' : implode(', ', $details);

            return [
                'passed' => $passed,
                'message' => $message,
            ];

        } catch (\Exception $e) {
            return [
                'passed' => false,
                'message' => 'Error reading file: ' . $e->getMessage(),
            ];
        }
    }

    protected function checkRequiredTables(string $file, bool $detailed): array
    {
        if (!File::exists($file)) {
            return ['passed' => false, 'message' => 'File not found'];
        }

        try {
            $content = $this->readFileContent($file);
            $foundTables = [];
            $missingTables = [];

            foreach ($this->requiredTables as $table) {
                if (preg_match("/CREATE TABLE.*`{$table}`/i", $content)) {
                    $foundTables[] = $table;
                } else {
                    $missingTables[] = $table;
                }
            }

            $passed = empty($missingTables);
            $message = sprintf(
                '%d/%d tables found',
                count($foundTables),
                count($this->requiredTables)
            );

            if ($detailed && !empty($missingTables)) {
                $message .= ' (Missing: ' . implode(', ', $missingTables) . ')';
            }

            return [
                'passed' => $passed,
                'message' => $message,
            ];

        } catch (\Exception $e) {
            return [
                'passed' => false,
                'message' => 'Error checking tables: ' . $e->getMessage(),
            ];
        }
    }

    protected function readFileContent(string $file, int $maxLines = 1000): string
    {
        if (substr($file, -3) === '.gz') {
            // 讀取壓縮檔的前幾行
            $command = sprintf('gunzip -c %s | head -n %d', escapeshellarg($file), $maxLines);
            return shell_exec($command) ?? '';
        }

        // 讀取一般檔案的前幾行
        $handle = fopen($file, 'r');
        $content = '';
        $lines = 0;

        while (!feof($handle) && $lines < $maxLines) {
            $content .= fgets($handle);
            $lines++;
        }

        fclose($handle);
        return $content;
    }

    protected function formatBytes(int $bytes, int $precision = 2): string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);

        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
```

### 4.4 MonitorBackups 命令

位置: `app/Console/Commands/MonitorBackups.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;

class MonitorBackups extends Command
{
    protected $signature = 'db:monitor-backups
                            {--report : Generate and send backup status report}
                            {--alert : Send alerts if issues detected}';

    protected $description = 'Monitor backup status and health';

    public function handle()
    {
        $this->info('Monitoring backup status...');
        $this->newLine();

        $backupDir = storage_path('backups');
        $checks = [
            'Recent Backup' => $this->checkRecentBackup($backupDir),
            'Disk Space' => $this->checkDiskSpace($backupDir),
            'Backup Count' => $this->checkBackupCount($backupDir),
            'File Sizes' => $this->checkFileSizes($backupDir),
        ];

        // 顯示結果
        $issues = [];
        foreach ($checks as $check => $result) {
            $status = $result['passed'] ? '✓' : '✗';
            $color = $result['passed'] ? 'green' : 'yellow';

            $this->line("<fg={$color}>{$status} {$check}: {$result['message']}</>");

            if (!$result['passed']) {
                $issues[] = "{$check}: {$result['message']}";
            }
        }

        $this->newLine();

        // 發送警報
        if ($this->option('alert') && !empty($issues)) {
            $this->warn('Issues detected! Sending alert...');
            $this->sendAlert($issues);
        }

        // 生成報告
        if ($this->option('report')) {
            $this->generateReport($checks);
        }

        return empty($issues) ? 0 : 1;
    }

    protected function checkRecentBackup(string $backupDir): array
    {
        $dailyDir = $backupDir . '/daily';
        if (!File::exists($dailyDir)) {
            return ['passed' => false, 'message' => 'Daily backup directory not found'];
        }

        $files = File::files($dailyDir);
        if (empty($files)) {
            return ['passed' => false, 'message' => 'No backup files found'];
        }

        // 找最新的備份檔案
        usort($files, function($a, $b) {
            return File::lastModified($b) - File::lastModified($a);
        });

        $latestFile = $files[0];
        $lastModified = File::lastModified($latestFile);
        $hoursSinceBackup = (time() - $lastModified) / 3600;

        $passed = $hoursSinceBackup < 26; // 26 小時內應有備份
        $message = sprintf(
            'Last backup: %s (%.1f hours ago)',
            date('Y-m-d H:i:s', $lastModified),
            $hoursSinceBackup
        );

        return ['passed' => $passed, 'message' => $message];
    }

    protected function checkDiskSpace(string $backupDir): array
    {
        $freeSpace = disk_free_space($backupDir);
        $totalSpace = disk_total_space($backupDir);
        $usedPercent = (1 - $freeSpace / $totalSpace) * 100;

        $passed = $usedPercent < 90;
        $message = sprintf(
            'Free: %s / Total: %s (%.1f%% used)',
            $this->formatBytes($freeSpace),
            $this->formatBytes($totalSpace),
            $usedPercent
        );

        return ['passed' => $passed, 'message' => $message];
    }

    protected function checkBackupCount(string $backupDir): array
    {
        $counts = [];
        foreach (['daily', 'weekly', 'monthly'] as $type) {
            $dir = $backupDir . '/' . $type;
            if (File::exists($dir)) {
                $counts[$type] = count(File::files($dir));
            } else {
                $counts[$type] = 0;
            }
        }

        $passed = $counts['daily'] > 0;
        $message = sprintf(
            'Daily: %d, Weekly: %d, Monthly: %d',
            $counts['daily'],
            $counts['weekly'],
            $counts['monthly']
        );

        return ['passed' => $passed, 'message' => $message];
    }

    protected function checkFileSizes(string $backupDir): array
    {
        $dailyDir = $backupDir . '/daily';
        if (!File::exists($dailyDir)) {
            return ['passed' => false, 'message' => 'Daily backup directory not found'];
        }

        $files = File::files($dailyDir);
        if (empty($files)) {
            return ['passed' => false, 'message' => 'No backup files found'];
        }

        $sizes = array_map(function($file) {
            return File::size($file);
        }, $files);

        $avgSize = array_sum($sizes) / count($sizes);
        $latestSize = File::size($files[0]);

        // 檢查最新備份大小是否異常（與平均值差異超過 50%）
        $deviation = abs($latestSize - $avgSize) / $avgSize;
        $passed = $deviation < 0.5;

        $message = sprintf(
            'Latest: %s, Average: %s',
            $this->formatBytes($latestSize),
            $this->formatBytes($avgSize)
        );

        if (!$passed) {
            $message .= ' (Abnormal size detected)';
        }

        return ['passed' => $passed, 'message' => $message];
    }

    protected function sendAlert(array $issues): void
    {
        Log::warning('Backup monitoring issues detected', ['issues' => $issues]);

        // 這裡可以整合郵件或 Slack 通知
        // Mail::to('admin@example.com')->send(new BackupAlert($issues));
    }

    protected function generateReport(array $checks): void
    {
        $this->info('Generating backup status report...');

        $report = "Backup Status Report\n";
        $report .= "Generated: " . now()->format('Y-m-d H:i:s') . "\n\n";

        foreach ($checks as $check => $result) {
            $status = $result['passed'] ? '[PASS]' : '[FAIL]';
            $report .= "{$status} {$check}: {$result['message']}\n";
        }

        Log::info('Backup status report', ['report' => $report]);
        $this->info($report);
    }

    protected function formatBytes(int $bytes, int $precision = 2): string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);

        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
```

---

## 5. 備份驗證機制

### 5.1 備份完整性檢查

已在第 4.3 節提供完整的 `VerifyBackup` 命令實作，該命令會檢查:
- ✅ 檔案是否存在
- ✅ 檔案大小是否合理（1KB - 10GB）
- ✅ 檔案是否可讀取
- ✅ SQL 檔案基本結構檢查
- ✅ 關鍵資料表是否存在（users, orders, order_sequences, customers, drivers, landmarks）

**使用方式**:
```bash
# 基本驗證
php artisan db:verify-backup storage/backups/daily/lc_management_2025_11_03_020000.sql.gz

# 詳細驗證（顯示缺少的資料表）
php artisan db:verify-backup storage/backups/daily/lc_management_2025_11_03_020000.sql.gz --detailed
```

### 5.2 自動化驗證流程

在 Laravel 排程中加入自動驗證（已在第 3.2 節的排程設定中包含監控任務）：

```php
// 在 app/Console/Kernel.php 中
$schedule->command('db:backup --type=full --compress')
         ->dailyAt('02:00')
         ->onSuccess(function () {
             // 備份完成後自動驗證
             Artisan::call('db:verify-backup', [
                 'backup-file' => storage_path('backups/daily/latest.sql.gz')
             ]);
         });
```

---

## 6. 還原流程與災難復原

### 6.1 完整還原流程

#### 步驟 1: 評估備份檔案
```bash
# 列出可用備份
php artisan db:list-backups

# 驗證備份檔案
php artisan db:verify-backup storage/backups/daily/lc_management_2025_11_03_020000.sql.gz
```

#### 步驟 2: 備份當前資料庫 (安全措施)
```bash
# 在還原前先備份當前狀態
php artisan db:backup --type=full --compress
```

#### 步驟 3: 執行還原
```bash
# 還原完整備份
php artisan db:restore storage/backups/daily/lc_management_2025_11_03_020000.sql.gz

# 或使用 mysqldump 手動還原
cd C:\xampp\mysql\bin
mysql -uroot lc_management < "C:\xampp\htdocs\LC-management\storage\backups\daily\lc_management_2025_11_03_020000.sql"
```

#### 步驟 4: 驗證還原結果
```bash
# 執行資料庫遷移檢查
php artisan migrate:status

# 檢查關鍵資料表記錄數
php artisan tinker
>>> DB::table('orders')->count()
>>> DB::table('customers')->count()
>>> DB::table('drivers')->count()

# 清除所有快取
php artisan optimize:clear
```

### 5.2 部分表還原

有時只需要還原特定資料表:

```bash
# 從完整備份中提取特定表
sed -n '/CREATE TABLE `orders`/,/UNLOCK TABLES;/p' backup.sql > orders_only.sql

# 還原單一資料表
mysql -uroot lc_management < orders_only.sql
```

### 5.3 災難復原計畫 (Disaster Recovery Plan)

#### 情境 1: 資料庫完全損壞
```
1. 停止 Apache 和 MySQL 服務
2. 從最近的完整備份還原
3. 驗證資料完整性
4. 重新啟動服務
5. 執行系統測試
```

#### 情境 2: 部分資料損壞或誤刪除
```
1. 識別問題範圍 (哪些表/記錄受影響)
2. 從備份中提取受影響的表
3. 比對差異,確認還原範圍
4. 執行部分還原
5. 驗證資料一致性
```

#### 情境 3: 共乘群組資料損壞 (特殊情境)
由於 LC-management 系統具有複雜的共乘群組關聯，需要進行多層次驗證：

**完整的共乘群組完整性檢查 SQL**:

```sql
-- ============================================
-- 檢查 1: 每個共乘群組應該只有一個主訂單
-- ============================================
SELECT
    carpool_group_id,
    COUNT(*) as main_order_count,
    GROUP_CONCAT(id) as order_ids
FROM orders
WHERE carpool_group_id IS NOT NULL
  AND is_main_order = 1
GROUP BY carpool_group_id
HAVING main_order_count != 1;

-- 預期結果：應該是空集合
-- 如果有結果，表示某些群組有多個主訂單或沒有主訂單

-- ============================================
-- 檢查 2: 群組成員數量一致性
-- ============================================
SELECT
    carpool_group_id,
    COUNT(*) as actual_member_count,
    MAX(carpool_member_count) as declared_member_count,
    GROUP_CONCAT(id) as order_ids
FROM orders
WHERE carpool_group_id IS NOT NULL
GROUP BY carpool_group_id
HAVING actual_member_count != declared_member_count;

-- 預期結果：應該是空集合
-- 如果有結果，表示實際成員數與宣告數不符

-- ============================================
-- 檢查 3: 去程回程群組 ID 配對完整性
-- ============================================
-- 檢查去程群組 ID 是否存在對應訂單
SELECT
    o1.id as orphan_order_id,
    o1.outbound_carpool_group_id,
    'outbound' as direction
FROM orders o1
LEFT JOIN orders o2 ON o1.outbound_carpool_group_id = o2.carpool_group_id
WHERE o1.outbound_carpool_group_id IS NOT NULL
  AND o2.id IS NULL;

-- 檢查回程群組 ID 是否存在對應訂單
SELECT
    o1.id as orphan_order_id,
    o1.return_carpool_group_id,
    'return' as direction
FROM orders o1
LEFT JOIN orders o2 ON o1.return_carpool_group_id = o2.carpool_group_id
WHERE o1.return_carpool_group_id IS NOT NULL
  AND o2.id IS NULL;

-- 預期結果：應該都是空集合
-- 如果有結果，表示有訂單引用不存在的共乘群組

-- ============================================
-- 檢查 4: 共乘群組日期與時間一致性
-- ============================================
SELECT
    carpool_group_id,
    COUNT(DISTINCT ride_date) as date_count,
    COUNT(DISTINCT pickup_time) as time_count,
    GROUP_CONCAT(DISTINCT ride_date) as dates,
    GROUP_CONCAT(DISTINCT pickup_time) as times
FROM orders
WHERE carpool_group_id IS NOT NULL
GROUP BY carpool_group_id
HAVING date_count > 1 OR time_count > 1;

-- 預期結果：應該是空集合
-- 同一共乘群組的訂單應該有相同的日期和上車時間

-- ============================================
-- 自動修復建議（謹慎使用）
-- ============================================

-- 情況 1: 修復缺少主訂單標記的群組（將第一筆設為主訂單）
-- 警告：僅在確認群組內只應有一個主訂單時使用
UPDATE orders
SET is_main_order = 1
WHERE id IN (
    SELECT id FROM (
        SELECT MIN(id) as id
        FROM orders
        WHERE carpool_group_id IN (
            SELECT carpool_group_id
            FROM orders
            WHERE carpool_group_id IS NOT NULL
            GROUP BY carpool_group_id
            HAVING SUM(CASE WHEN is_main_order = 1 THEN 1 ELSE 0 END) = 0
        )
        GROUP BY carpool_group_id
    ) as subquery
);

-- 情況 2: 修復成員計數不符（重新計算）
UPDATE orders o1
JOIN (
    SELECT carpool_group_id, COUNT(*) as correct_count
    FROM orders
    WHERE carpool_group_id IS NOT NULL
    GROUP BY carpool_group_id
) o2 ON o1.carpool_group_id = o2.carpool_group_id
SET o1.carpool_member_count = o2.correct_count
WHERE o1.carpool_group_id IS NOT NULL;

-- ============================================
-- 完整性驗證報告查詢
-- ============================================
SELECT
    '共乘群組總數' as metric,
    COUNT(DISTINCT carpool_group_id) as value
FROM orders
WHERE carpool_group_id IS NOT NULL

UNION ALL

SELECT
    '共乘訂單總數' as metric,
    COUNT(*) as value
FROM orders
WHERE carpool_group_id IS NOT NULL

UNION ALL

SELECT
    '主訂單總數' as metric,
    COUNT(*) as value
FROM orders
WHERE is_main_order = 1

UNION ALL

SELECT
    '孤立的共乘群組 ID' as metric,
    COUNT(DISTINCT carpool_group_id) as value
FROM orders o1
WHERE carpool_group_id IS NOT NULL
  AND NOT EXISTS (
      SELECT 1 FROM orders o2
      WHERE o2.carpool_group_id = o1.carpool_group_id
        AND o2.is_main_order = 1
  );

-- ============================================
-- 還原流程（如果驗證失敗）
-- ============================================
-- 1. 從最近的備份中提取 orders 表
-- 2. 還原到臨時表進行比對
-- 3. 識別損壞的共乘群組
-- 4. 選擇性還原受影響的訂單
```

**共乘群組資料還原步驟**:
```bash
# 步驟 1: 從備份提取 orders 表
mysql -uroot lc_management < backup_orders.sql

# 步驟 2: 執行完整性檢查
mysql -uroot lc_management -e "SOURCE carpool_integrity_check.sql" > integrity_report.txt

# 步驟 3: 如果發現問題，從備份中還原
# （建議先備份當前狀態）
mysqldump --defaults-file=my_backup.cnf --single-transaction lc_management orders > orders_before_restore.sql

# 步驟 4: 還原
mysql -uroot lc_management < orders_backup_verified.sql
```

### 5.4 復原時間目標 (RTO) 與復原點目標 (RPO)

| 指標 | 當前目標 | 建議目標 | 說明 |
|-----|---------|---------|------|
| **RTO** (Recovery Time Objective) | < 1 小時 | < 30 分鐘 | 系統完全恢復運作的時間 |
| **RPO** (Recovery Point Objective) | < 24 小時 | **< 4 小時** | 可接受的資料損失範圍 |
| 備份驗證時間 | < 5 分鐘 | < 3 分鐘 | 備份完整性驗證時間 |
| 部分還原時間 | < 15 分鐘 | < 10 分鐘 | 單一資料表還原時間 |
| 完整系統測試時間 | - | < 20 分鐘 | 還原後功能驗證時間 |

**重要說明**:

1. **RPO 縮短建議**
   - 長照服務系統，訂單資料極為重要，24 小時的資料損失風險過高
   - 建議實施**每 4 小時的關鍵表備份**（orders, order_sequences, customers）
   - 可將 RPO 縮短至 4 小時，大幅降低資料損失風險

2. **達成建議目標的策略**:
   - ✅ 每日完整備份（凌晨 2:00）
   - ✅ 每 4 小時關鍵表備份
   - ✅ 啟用 MySQL Binary Log（增量備份）
   - ✅ 本地 + 遠端雙重備份
   - ✅ 自動化監控與警報

3. **增量備份策略（建議實施）**:
   ```bash
   # 啟用 MySQL Binary Log（在 my.ini 中設定）
   [mysqld]
   log-bin=mysql-bin
   binlog_format=ROW
   expire_logs_days=7
   max_binlog_size=100M

   # 每小時備份 Binary Log
   mysqlbinlog --read-from-remote-server --host=localhost --user=root mysql-bin.000001 > binlog_backup.sql
   ```

4. **RPO/RTO 對照表**:

   | 備份頻率 | RPO | 適用場景 |
   |---------|-----|---------|
   | 每日一次 | 24 小時 | 低頻更新系統 |
   | 每 6 小時 | 6 小時 | 一般業務系統 |
   | **每 4 小時** | **4 小時** | **重要業務系統（建議）** |
   | 每小時 + Binary Log | 1 小時 | 關鍵業務系統 |
   | 即時複製 | 近 0 | 金融級系統 |

---

## 7. 儲存與安全策略

### 7.1 本地儲存配置

#### 目錄結構
```
storage/backups/
├── daily/              # 每日備份 (30 天)
├── weekly/             # 每週備份 (12 週)
├── monthly/            # 每月備份 (12 個月)
├── manual/             # 手動備份 (永久)
├── critical/           # 關鍵表備份 (7 天)
└── schema/             # 結構備份 (最新版本)
```

#### 權限設定
```bash
# Linux/macOS
chmod 700 storage/backups/
chmod 600 storage/backups/**/*.sql*

# Windows (使用 icacls)
icacls "C:\xampp\htdocs\LC-management\storage\backups" /inheritance:r /grant:r "%USERNAME%:(OI)(CI)F"
```

### 6.2 壓縮與加密

#### 壓縮備份 (使用 gzip)
```bash
# 壓縮備份檔案 (可減少 70-90% 大小)
gzip backup.sql

# 解壓縮
gunzip backup.sql.gz
```

#### 加密備份 (使用 OpenSSL)
```bash
# 加密備份檔案
openssl enc -aes-256-cbc -salt -in backup.sql -out backup.sql.enc -k "your_strong_password"

# 解密備份檔案
openssl enc -aes-256-cbc -d -in backup.sql.enc -out backup.sql -k "your_strong_password"
```

#### 整合壓縮與加密
```bash
# 備份 -> 壓縮 -> 加密
mysqldump -uroot lc_management | gzip | openssl enc -aes-256-cbc -salt -out backup.sql.gz.enc -k "password"

# 解密 -> 解壓縮 -> 還原
openssl enc -aes-256-cbc -d -in backup.sql.gz.enc -k "password" | gunzip | mysql -uroot lc_management
```

### 6.3 遠端備份方案

#### 方案 1: Google Drive 同步
使用 `rclone` 或 Google Drive 備份工具:

```bash
# 安裝 rclone (Windows)
# 下載: https://rclone.org/downloads/

# 設定 Google Drive
rclone config

# 同步備份到雲端
rclone sync "C:\xampp\htdocs\LC-management\storage\backups" gdrive:LC-Management-Backups
```

#### 方案 2: FTP/SFTP 傳輸
```php
// Laravel 檔案系統設定 (config/filesystems.php)
'disks' => [
    'ftp_backup' => [
        'driver' => 'ftp',
        'host' => env('FTP_HOST'),
        'username' => env('FTP_USERNAME'),
        'password' => env('FTP_PASSWORD'),
        'root' => '/backups',
    ],
],

// 上傳備份到 FTP
Storage::disk('ftp_backup')->put('backup.sql.gz', file_get_contents($localBackupPath));
```

#### 方案 3: AWS S3 / Azure Blob Storage
```php
// config/filesystems.php
'disks' => [
    's3_backup' => [
        'driver' => 's3',
        'key' => env('AWS_ACCESS_KEY_ID'),
        'secret' => env('AWS_SECRET_ACCESS_KEY'),
        'region' => env('AWS_DEFAULT_REGION'),
        'bucket' => env('AWS_BACKUP_BUCKET'),
    ],
],
```

### 6.4 備份檔案命名規範

```
格式: {database}_{type}_{timestamp}.sql[.gz][.enc]

範例:
- lc_management_full_2025_11_03_020000.sql.gz
- lc_management_schema_2025_11_03.sql
- lc_management_tables_orders_2025_11_03_140000.sql.gz
- lc_management_manual_before_v2_migration.sql.gz.enc
```

---

## 8. 監控與通知機制

### 8.1 備份狀態監控

已在第 4.4 節提供完整的 `MonitorBackups` 命令實作。該命令會進行以下檢查:
- ✅ 最近 26 小時內是否有備份
- ✅ 磁碟空間是否充足（< 90% 使用率）
- ✅ 各類型備份數量是否正常（daily、weekly、monthly）
- ✅ 備份檔案大小是否異常（與平均值比較，偏差 > 50% 發出警告）

**使用方式**:
```bash
# 基本監控
php artisan db:monitor-backups

# 生成報告
php artisan db:monitor-backups --report

# 偵測問題時發送警報
php artisan db:monitor-backups --alert
```

### 8.2 自動化監控排程

已在第 3.2 節的 Laravel Task Scheduling 中設定，包含：

```php
// 每小時檢查備份狀態
$schedule->command('db:monitor-backups')
         ->hourly()
         ->withoutOverlapping();

// 每天早上 9:00 發送備份狀態報告
$schedule->command('db:monitor-backups --report')
         ->dailyAt('09:00')
         ->emailOutputTo('admin@example.com');
```

### 8.3 郵件通知設定

在 `.env` 中設定郵件服務：

```env
MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=your-username
MAIL_PASSWORD=your-password
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=backup@example.com
MAIL_FROM_NAME="LC-Management Backup System"
```

Laravel 排程任務可使用以下方法發送通知：
- `->emailOutputOnFailure('admin@example.com')` - 失敗時發送輸出
- `->emailOutputTo('admin@example.com')` - 總是發送輸出

### 8.4 Slack 通知整合 (可選)

```bash
# 安裝 Slack 通知套件
composer require laravel/slack-notification-channel
```

---

## 9. 開發指令速查表

### 9.1 備份指令

```bash
# 完整備份 (含壓縮)
php artisan db:backup --type=full --compress

# 僅備份結構
php artisan db:backup --type=schema

# 備份特定資料表
php artisan db:backup --type=tables --tables=orders,customers,drivers

# 備份並加密
php artisan db:backup --type=full --compress --encrypt

# 手動快速備份 (Windows)
cd C:\xampp\mysql\bin
mysqldump -uroot lc_management > C:\xampp\htdocs\LC-management\storage\backups\manual\backup_%date:~0,10%.sql
```

### 9.2 還原指令

```bash
# 從備份還原
php artisan db:restore storage/backups/daily/lc_management_2025_11_03_020000.sql.gz

# 手動還原 (Windows)
cd C:\xampp\mysql\bin
mysql -uroot lc_management < C:\xampp\htdocs\LC-management\storage\backups\daily\lc_management_2025_11_03_020000.sql

# 還原壓縮備份 (Linux/Mac)
gunzip < backup.sql.gz | mysql -uroot lc_management
```

### 9.3 驗證與監控指令

```bash
# 驗證備份檔案
php artisan db:verify-backup storage/backups/daily/backup.sql.gz

# 監控備份狀態
php artisan db:monitor-backups

# 監控並發送警報
php artisan db:monitor-backups --alert

# 列出所有備份
php artisan db:list-backups
```

### 9.4 維護指令

```bash
# 清理舊備份 (超過 30 天)
find storage/backups/daily -name "*.sql*" -mtime +30 -delete

# 清理舊備份 (Windows)
forfiles /p "C:\xampp\htdocs\LC-management\storage\backups\daily" /s /m *.sql* /d -30 /c "cmd /c del @path"

# 檢查儲存空間
df -h storage/backups/  # Linux/Mac
dir "C:\xampp\htdocs\LC-management\storage\backups"  # Windows

# 計算備份總大小
du -sh storage/backups/*  # Linux/Mac
```

---

## 10. 測試與驗證

### 10.1 備份還原測試計畫

建議每季度執行一次完整的備份還原測試:

#### 測試步驟
```bash
# 1. 建立測試資料庫
mysql -uroot -e "CREATE DATABASE lc_management_test;"

# 2. 執行備份
php artisan db:backup --type=full --compress

# 3. 還原到測試資料庫
mysql -uroot lc_management_test < storage/backups/daily/latest_backup.sql

# 4. 驗證資料一致性
php artisan tinker
>>> DB::connection('mysql')->table('orders')->count()
>>> DB::connection('mysql_test')->table('orders')->count()

# 5. 清理測試資料庫
mysql -uroot -e "DROP DATABASE lc_management_test;"
```

### 10.2 災難復原演練

**演練情境**: 模擬生產資料庫損壞,需完整復原

```bash
# 記錄開始時間
echo "演練開始時間: $(date)"

# 步驟 1: 停止服務 (模擬)
# 在生產環境應執行: php artisan down

# 步驟 2: 識別最新備份
ls -lh storage/backups/daily/ | tail -5

# 步驟 3: 驗證備份
php artisan db:verify-backup storage/backups/daily/latest.sql.gz

# 步驟 4: 執行還原
php artisan db:restore storage/backups/daily/latest.sql.gz

# 步驟 5: 驗證資料
php artisan tinker
>>> DB::table('orders')->count()

# 步驟 6: 恢復服務 (模擬)
# 在生產環境應執行: php artisan up

# 記錄結束時間並計算復原時間
echo "演練結束時間: $(date)"
```

---

## 11. 常見問題與排除

### Q1: 備份檔案過大,如何優化?

**解答**:
```bash
# 1. 使用壓縮 (可減少 70-90% 大小)
php artisan db:backup --compress

# 2. 排除不重要的表
mysqldump -uroot lc_management --ignore-table=lc_management.sessions --ignore-table=lc_management.jobs > backup.sql

# 3. 僅備份最近 90 天的資料
mysqldump -uroot lc_management orders --where="ride_date >= DATE_SUB(NOW(), INTERVAL 90 DAY)" > orders_recent.sql
```

### Q2: mysqldump 執行很慢怎麼辦?

**解答**:
```bash
# 使用 --single-transaction 避免鎖表 (InnoDB)
mysqldump -uroot --single-transaction lc_management > backup.sql

# 使用 --quick 選項減少記憶體使用
mysqldump -uroot --quick --single-transaction lc_management > backup.sql

# 排除大型不重要的表
mysqldump -uroot --ignore-table=lc_management.logs lc_management > backup.sql
```

### Q3: 還原時出現字元編碼錯誤?

**解答**:
```bash
# 確保使用正確的字元編碼
mysql -uroot --default-character-set=utf8mb4 lc_management < backup.sql

# 或在備份時指定編碼
mysqldump -uroot --default-character-set=utf8mb4 lc_management > backup.sql
```

### Q4: Windows Task Scheduler 排程未執行?

**解答**:
1. 檢查使用者權限 (應使用 SYSTEM 帳戶)
2. 確認批次腳本路徑正確且可執行
3. 查看工作排程器的歷史記錄
4. 測試手動執行批次腳本是否正常

### Q5: 如何確認備份是否包含所有資料?

**解答**:
```bash
# 驗證備份檔案
php artisan db:verify-backup storage/backups/daily/backup.sql.gz

# 檢查備份檔案的表數量
grep -c "CREATE TABLE" backup.sql

# 檢查特定表是否存在
grep "CREATE TABLE \`orders\`" backup.sql
```

---

## 12. 進階主題

### 12.1 增量備份 (Incremental Backup)

MySQL 二進制日誌 (Binary Log) 增量備份:

```bash
# 啟用二進制日誌 (my.ini 或 my.cnf)
[mysqld]
log-bin=mysql-bin
expire_logs_days=7

# 刷新日誌
mysql -uroot -e "FLUSH LOGS;"

# 備份二進制日誌
mysqlbinlog mysql-bin.000001 > binlog_backup.sql

# 還原增量備份
mysql -uroot lc_management < binlog_backup.sql
```

### 12.2 主從複製 (Replication) 作為備份策略

```sql
-- 在主伺服器設定
CREATE USER 'repl'@'slave_ip' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'slave_ip';

-- 在從伺服器設定
CHANGE MASTER TO
    MASTER_HOST='master_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=107;

START SLAVE;
```

### 12.3 自動化測試備份可還原性

可建立自動化測試來驗證備份和還原功能是否正常運作。

---

## 13. 效能影響評估

### 13.1 備份對系統效能的影響

#### CPU 使用率
- **mysqldump 備份**: 中等 CPU 使用（10-30%）
- **壓縮過程 (gzip)**: 高 CPU 使用（40-80%）
- **建議**: 在系統低負載時段執行（凌晨 2:00-5:00）

#### 記憶體使用
| 操作類型 | 記憶體使用量 | 說明 |
|---------|-----------|------|
| 完整備份 (5GB 資料庫) | ~200-500MB | mysqldump 緩衝區 |
| 壓縮備份檔案 | ~50-100MB | gzip 工作記憶體 |
| 還原操作 | ~500MB-1GB | mysql 匯入緩衝區 |
| 監控命令 | ~20-50MB | 檔案掃描與統計 |

#### I/O 影響
- **讀取 I/O**: 完整資料庫掃描，可能影響同時進行的查詢
- **寫入 I/O**: 備份檔案寫入，視磁碟速度而定
- **緩解措施**: 使用 `--single-transaction` 避免鎖表

### 13.2 備份時間窗口建議

基於 LC-management 系統特性：

| 資料庫大小 | 預估備份時間 | 建議執行時間 | 備註 |
|-----------|------------|------------|------|
| < 1GB | 2-5 分鐘 | 隨時可執行 | 影響極小 |
| 1-5GB | 5-15 分鐘 | 凌晨 2:00-5:00 | 一般業務時段 |
| 5-10GB | 15-30 分鐘 | 凌晨 1:00-5:00 | 避開高峰 |
| > 10GB | 30-60 分鐘 | 凌晨 12:00-4:00 | 需專門規劃 |

**當前系統估算**:
- orders 表：預估 500MB-2GB（視訂單數量）
- customers 表：預估 100-500MB
- 完整資料庫：預估 1-3GB
- **預期備份時間**: 5-10 分鐘（含壓縮）

### 13.3 併發控制與備份的關係

#### orders 表與 order_sequences 表的特殊考量

LC-management 系統使用 `order_sequences` 表進行併發控制，備份時需要特別注意：

```sql
-- 備份必須在同一事務中捕獲這兩個表
-- 使用 --single-transaction 確保一致性
mysqldump --single-transaction lc_management orders order_sequences
```

**重要提醒**:
- ✅ `--single-transaction` 確保 InnoDB 表的一致性快照
- ✅ 備份期間不會阻塞訂單建立操作
- ✅ 使用 SELECT FOR UPDATE 的併發訂單建立不受影響
- ⚠️ 長時間備份可能導致 undo log 增長

### 13.4 效能最佳化建議

#### 1. 資料表層級最佳化

```sql
-- 定期分析表以更新統計資訊
ANALYZE TABLE orders, order_sequences, customers, drivers;

-- 檢查表碎片化
SELECT
    table_name,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    ROUND(data_free / data_length * 100, 2) AS fragmentation_pct
FROM information_schema.tables
WHERE table_schema = 'lc_management'
    AND data_free > 0
ORDER BY fragmentation_pct DESC;

-- 如果碎片化超過 20%，執行最佳化
OPTIMIZE TABLE orders;
```

#### 2. 備份策略最佳化

**差異化備份頻率**:
```php
// 高頻變更表：每 4 小時
$schedule->command('db:backup --type=tables --tables=orders,order_sequences')
         ->cron('0 */4 * * *');

// 低頻變更表：每日
$schedule->command('db:backup --type=tables --tables=customers,drivers,landmarks')
         ->dailyAt('03:00');

// 完整備份：每日（壓縮）
$schedule->command('db:backup --type=full --compress')
         ->dailyAt('02:00');
```

#### 3. 並行備份策略

對於大型資料庫，可以並行備份不同的表：

```batch
REM 並行備份多個表（Windows）
start /B mysqldump --defaults-file=my_backup.cnf lc_management orders > orders.sql
start /B mysqldump --defaults-file=my_backup.cnf lc_management customers > customers.sql
start /B mysqldump --defaults-file=my_backup.cnf lc_management drivers > drivers.sql
```

### 13.5 效能監控指標

建議監控以下指標：

```sql
-- 1. 備份期間的慢查詢
SHOW VARIABLES LIKE 'slow_query_log%';
SHOW GLOBAL STATUS LIKE 'Slow_queries';

-- 2. InnoDB 緩衝池命中率
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_read%';

-- 3. 連線數變化
SHOW GLOBAL STATUS LIKE 'Threads_connected';
SHOW GLOBAL STATUS LIKE 'Max_used_connections';

-- 4. 鎖等待情況
SELECT * FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT';
```

### 13.6 效能基準測試

**建議執行基準測試**:

```bash
# 1. 測試備份時間
time php artisan db:backup --type=full

# 2. 測試壓縮時間
time php artisan db:backup --type=full --compress

# 3. 測試還原時間
time php artisan db:restore storage/backups/daily/latest.sql.gz

# 4. 記錄結果
echo "Backup Time: $(date)" >> performance_log.txt
```

**預期基準值（參考）**:
- 1GB 資料庫備份：3-5 分鐘
- 壓縮率：70-85%（SQL 檔案壓縮效果很好）
- 還原時間：備份時間的 1.5-2 倍
- 驗證時間：< 30 秒

---

## 14. 安全性與合規性

### 14.1 資料安全性要求

#### 長照資料的法規考量

長照服務管理系統涉及個人敏感資料，備份必須符合：
- ✅ 個人資料保護法（台灣）
- ✅ 醫療資料保護相關規範
- ✅ 服務機構內部資安政策

#### 備份檔案保護措施

**1. 存取控制**
```bash
# Linux/macOS 權限設定
chmod 700 storage/backups/           # 目錄：僅擁有者可完全存取
chmod 600 storage/backups/**/*.sql*  # 檔案：僅擁有者可讀寫

# Windows 權限設定
icacls "C:\xampp\htdocs\LC-management\storage\backups" /inheritance:r /grant:r "%USERNAME%:(OI)(CI)F"
```

**2. 加密傳輸**
```bash
# 使用 rsync 加密傳輸到遠端伺服器
rsync -avz -e "ssh -p 22" storage/backups/ user@remote:/backup/lc-management/

# 使用 scp 加密傳輸
scp -P 22 backup.sql.gz user@remote:/backup/
```

**3. 加密儲存**（可選，需要金鑰管理）
```bash
# 使用 GPG 加密
gpg --symmetric --cipher-algo AES256 backup.sql.gz

# 解密
gpg --decrypt backup.sql.gz.gpg > backup.sql.gz
```

### 14.2 存取稽核

#### 備份存取日誌

所有備份相關操作已透過 Laravel Log 記錄：

```php
// 在 config/logging.php 中設定專用日誌頻道
'channels' => [
    'backup' => [
        'driver' => 'daily',
        'path' => storage_path('logs/backup.log'),
        'level' => 'info',
        'days' => 90,  // 保留 90 天
    ],
],
```

#### 重要事件記錄

系統會自動記錄：
- ✅ 備份建立時間與檔案資訊
- ✅ 備份失敗事件與錯誤訊息
- ✅ 還原操作執行記錄
- ✅ 備份檔案驗證結果
- ✅ 備份監控異常警報

### 14.3 資料保存期限政策

| 資料類型 | 最低保存期限 | 建議保存期限 | 法規依據 |
|---------|-----------|------------|---------|
| 客戶個人資料 | 服務結束後 5 年 | 7 年 | 個資法、長照相關法規 |
| 訂單記錄 | 5 年 | 7 年 | 會計法、稅務法規 |
| 系統操作日誌 | 1 年 | 3 年 | 資安稽核需求 |
| 備份檔案 | 30 天 | 12 個月 | 業務連續性需求 |

**備份保留策略（符合上述要求）**:
- 每日備份：30 天
- 每週備份：12 週（3 個月）
- 每月備份：12 個月（1 年）
- 年度備份：永久保存（建議每年底手動備份並歸檔）

### 14.4 災難復原合規性

#### 業務連續性計畫 (BCP)

備份系統應納入 BCP 文件：

1. **復原時間目標 (RTO)**: < 30 分鐘
2. **復原點目標 (RPO)**: < 4 小時
3. **關鍵系統識別**: orders、order_sequences、customers
4. **緊急聯絡人**: 系統管理員、IT 主管
5. **定期演練**: 每季一次災難復原演練

#### 稽核要點

定期檢查項目：
- [ ] 備份是否按排程執行
- [ ] 備份檔案是否可成功還原
- [ ] 存取權限是否正確設定
- [ ] 遠端備份是否正常同步
- [ ] 備份日誌是否完整記錄
- [ ] 敏感資料是否適當保護

### 14.5 去敏感化測試資料

用於開發/測試環境的資料處理：

```sql
-- 建立去敏感化的備份（用於測試環境）
-- 1. 先建立完整備份
-- 2. 還原到臨時資料庫
-- 3. 執行去敏感化

USE lc_management_test;

-- 客戶資料去敏感化
UPDATE customers SET
    name = CONCAT('測試客戶', id),
    id_number = CONCAT('A', LPAD(id, 9, '0')),
    phones = JSON_ARRAY(CONCAT('0900', LPAD(id, 6, '0'))),
    addresses = JSON_ARRAY(CONCAT('測試地址 ', id, ' 號')),
    notes = '測試資料';

-- 司機資料去敏感化
UPDATE drivers SET
    name = CONCAT('測試司機', id),
    phone = CONCAT('0900', LPAD(id, 6, '0')),
    license_plate = CONCAT('TEST-', LPAD(id, 4, '0')),
    notes = '測試資料';

-- 訂單中的客戶快照去敏感化
UPDATE orders SET
    customer_snapshot = JSON_SET(
        customer_snapshot,
        '$.name', CONCAT('測試客戶', customer_id),
        '$.id_number', 'A000000000',
        '$.phones', JSON_ARRAY('0900000000')
    );

-- 4. 匯出去敏感化的資料庫
mysqldump lc_management_test > lc_management_sanitized.sql

-- 5. 清理臨時資料庫
DROP DATABASE lc_management_test;
```

### 14.6 安全檢查清單

**每月檢查**:
- [ ] 檢查備份檔案權限設定
- [ ] 審查備份存取日誌
- [ ] 驗證加密機制運作正常
- [ ] 確認遠端備份同步狀態
- [ ] 測試備份檔案可還原性

**每季檢查**:
- [ ] 執行完整災難復原演練
- [ ] 審查存取控制政策
- [ ] 更新緊急聯絡資訊
- [ ] 檢視合規性要求變更
- [ ] 評估備份策略有效性

**每年檢查**:
- [ ] 建立年度歸檔備份
- [ ] 審查並更新 BCP 文件
- [ ] 評估新的安全威脅
- [ ] 更新備份加密機制
- [ ] 進行外部稽核（如需要）

---

## 15. 檢查清單 (Checklist)

### 初次設定檢查清單
- [ ] 建立備份目錄結構 (`storage/backups/`)
- [ ] 設定目錄權限 (700 for directory, 600 for files)
- [ ] 測試 mysqldump 命令可正常執行
- [ ] 建立 Laravel Artisan 備份命令
- [ ] 設定 Laravel Task Scheduling
- [ ] 配置 Windows Task Scheduler (XAMPP 環境)
- [ ] 測試手動備份和還原
- [ ] 設定備份監控機制
- [ ] 配置通知系統 (郵件/Slack)
- [ ] 執行首次災難復原演練

### 每月檢查清單
- [ ] 驗證自動備份正常執行
- [ ] 檢查備份檔案大小和數量
- [ ] 清理過期備份檔案
- [ ] 檢查儲存空間使用狀況
- [ ] 測試最新備份的還原功能
- [ ] 檢查備份日誌和錯誤記錄
- [ ] 更新備份文檔和流程

### 每季檢查清單
- [ ] 執行完整災難復原演練
- [ ] 測試遠端備份同步功能
- [ ] 審查備份保留政策
- [ ] 檢查備份安全性設定
- [ ] 更新備份腳本和命令
- [ ] 培訓相關人員備份還原流程

---

## 16. 參考資源

### 官方文件
- [MySQL 備份與還原](https://dev.mysql.com/doc/refman/8.0/en/backup-and-recovery.html)
- [Laravel Task Scheduling](https://laravel.com/docs/10.x/scheduling)
- [mysqldump 完整參數說明](https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html)

### 工具下載
- [7-Zip (Windows 壓縮工具)](https://www.7-zip.org/)
- [rclone (雲端同步工具)](https://rclone.org/)
- [MySQL Workbench (資料庫管理)](https://www.mysql.com/products/workbench/)

### 相關專案文件
- `CLAUDE.md` - 專案整體說明
- `EXCEL_匯入格式規格說明.md` - Excel 匯入規格
- `共乘單方案.md` - 共乘功能設計

---

## 17. 版本更新記錄

| 版本 | 日期 | 更新內容 |
|-----|------|---------|
| 1.0 | 2025-11-03 | 初版建立,包含完整備份策略與實作方案 |
| 2.0 | 2025-11-19 | **重大更新**：安全性強化與功能完善<br>• 修復密碼安全問題（加入 my.cnf 配置方式）<br>• 完整改進 Windows 批次腳本（錯誤處理、磁碟空間檢查）<br>• 新增 4 個完整 Laravel Artisan 命令（Backup、Restore、Verify、Monitor）<br>• 強化 Laravel 排程設定（withoutOverlapping、通知機制）<br>• 完善共乘群組驗證 SQL（4項完整性檢查）<br>• 調整 RTO/RPO 目標（RPO 從 24 小時縮短為 4 小時）<br>• 新增第 13 章：效能影響評估<br>• 新增第 14 章：安全性與合規性<br>• 更新所有章節編號與交叉引用 |

---

## 18. 聯絡資訊與支援

如有備份相關問題或建議,請聯絡系統管理員。

**緊急聯絡**: 當資料庫備份或還原遇到問題時,請立即聯絡技術團隊。

---

*本文件應定期更新,確保與系統實際狀況同步*
